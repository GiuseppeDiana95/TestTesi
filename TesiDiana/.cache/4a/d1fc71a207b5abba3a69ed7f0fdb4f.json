{"id":"../node_modules/react-mosaic-component/lib/util/mosaicUtilities.js","dependencies":[{"name":"/home/giuseppe/Scrivania/TesiDiana/node_modules/react-mosaic-component/lib/util/mosaicUtilities.js.map","includedInParent":true,"mtime":1695993896509},{"name":"/home/giuseppe/Scrivania/TesiDiana/node_modules/react-mosaic-component/src/util/mosaicUtilities.ts","includedInParent":true,"mtime":1695993899400},{"name":"/home/giuseppe/Scrivania/TesiDiana/package.json","includedInParent":true,"mtime":1698312122672},{"name":"/home/giuseppe/Scrivania/TesiDiana/node_modules/react-mosaic-component/package.json","includedInParent":true,"mtime":1695993894381},{"name":"lodash/clone","loc":{"line":7,"column":38,"index":499},"parent":"/home/giuseppe/Scrivania/TesiDiana/node_modules/react-mosaic-component/lib/util/mosaicUtilities.js","resolved":"/home/giuseppe/Scrivania/TesiDiana/node_modules/lodash/clone.js"},{"name":"lodash/get","loc":{"line":8,"column":36,"index":553},"parent":"/home/giuseppe/Scrivania/TesiDiana/node_modules/react-mosaic-component/lib/util/mosaicUtilities.js","resolved":"/home/giuseppe/Scrivania/TesiDiana/node_modules/lodash/get.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAndAssertNodeAtPathExists = exports.getNodeAtPath = exports.getLeaves = exports.getPathToCorner = exports.getOtherDirection = exports.getOtherBranch = exports.createBalancedTreeFromLeaves = exports.isParent = exports.Corner = void 0;\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar get_1 = __importDefault(require(\"lodash/get\"));\nfunction alternateDirection(node, direction) {\n    if (direction === void 0) { direction = 'row'; }\n    if (isParent(node)) {\n        var nextDirection = getOtherDirection(direction);\n        return {\n            direction: direction,\n            first: alternateDirection(node.first, nextDirection),\n            second: alternateDirection(node.second, nextDirection),\n        };\n    }\n    else {\n        return node;\n    }\n}\nvar Corner;\n(function (Corner) {\n    Corner[Corner[\"TOP_LEFT\"] = 1] = \"TOP_LEFT\";\n    Corner[Corner[\"TOP_RIGHT\"] = 2] = \"TOP_RIGHT\";\n    Corner[Corner[\"BOTTOM_LEFT\"] = 3] = \"BOTTOM_LEFT\";\n    Corner[Corner[\"BOTTOM_RIGHT\"] = 4] = \"BOTTOM_RIGHT\";\n})(Corner = exports.Corner || (exports.Corner = {}));\n/**\n * Returns `true` if `node` is a MosaicParent\n * @param node\n * @returns {boolean}\n */\nfunction isParent(node) {\n    return node.direction != null;\n}\nexports.isParent = isParent;\n/**\n * Creates a balanced binary tree from `leaves` with the goal of making them as equal area as possible\n * @param leaves\n * @param startDirection\n * @returns {MosaicNode<T>}\n */\nfunction createBalancedTreeFromLeaves(leaves, startDirection) {\n    if (startDirection === void 0) { startDirection = 'row'; }\n    if (leaves.length === 0) {\n        return null;\n    }\n    var current = clone_1.default(leaves);\n    var next = [];\n    while (current.length > 1) {\n        while (current.length > 0) {\n            if (current.length > 1) {\n                next.push({\n                    direction: 'row',\n                    first: current.shift(),\n                    second: current.shift(),\n                });\n            }\n            else {\n                next.unshift(current.shift());\n            }\n        }\n        current = next;\n        next = [];\n    }\n    return alternateDirection(current[0], startDirection);\n}\nexports.createBalancedTreeFromLeaves = createBalancedTreeFromLeaves;\n/**\n * Gets the sibling of `branch`\n * @param branch\n * @returns {any}\n */\nfunction getOtherBranch(branch) {\n    if (branch === 'first') {\n        return 'second';\n    }\n    else if (branch === 'second') {\n        return 'first';\n    }\n    else {\n        throw new Error(\"Branch '\" + branch + \"' not a valid branch\");\n    }\n}\nexports.getOtherBranch = getOtherBranch;\n/**\n * Gets the opposite of `direction`\n * @param direction\n * @returns {any}\n */\nfunction getOtherDirection(direction) {\n    if (direction === 'row') {\n        return 'column';\n    }\n    else {\n        return 'row';\n    }\n}\nexports.getOtherDirection = getOtherDirection;\n/**\n * Traverses `tree` to find the path to the specified `corner`\n * @param tree\n * @param corner\n * @returns {MosaicPath}\n */\nfunction getPathToCorner(tree, corner) {\n    var currentNode = tree;\n    var currentPath = [];\n    while (isParent(currentNode)) {\n        if (currentNode.direction === 'row' && (corner === Corner.TOP_LEFT || corner === Corner.BOTTOM_LEFT)) {\n            currentPath.push('first');\n            currentNode = currentNode.first;\n        }\n        else if (currentNode.direction === 'column' && (corner === Corner.TOP_LEFT || corner === Corner.TOP_RIGHT)) {\n            currentPath.push('first');\n            currentNode = currentNode.first;\n        }\n        else {\n            currentPath.push('second');\n            currentNode = currentNode.second;\n        }\n    }\n    return currentPath;\n}\nexports.getPathToCorner = getPathToCorner;\n/**\n * Gets all leaves of `tree`\n * @param tree\n * @returns {T[]}\n */\nfunction getLeaves(tree) {\n    if (tree == null) {\n        return [];\n    }\n    else if (isParent(tree)) {\n        return getLeaves(tree.first).concat(getLeaves(tree.second));\n    }\n    else {\n        return [tree];\n    }\n}\nexports.getLeaves = getLeaves;\n/**\n * Gets node at `path` from `tree`\n * @param tree\n * @param path\n * @returns {MosaicNode<T>|null}\n */\nfunction getNodeAtPath(tree, path) {\n    if (path.length > 0) {\n        return get_1.default(tree, path, null);\n    }\n    else {\n        return tree;\n    }\n}\nexports.getNodeAtPath = getNodeAtPath;\n/**\n * Gets node at `path` from `tree` and verifies that neither `tree` nor the result are null\n * @param tree\n * @param path\n * @returns {MosaicNode<T>}\n */\nfunction getAndAssertNodeAtPathExists(tree, path) {\n    if (tree == null) {\n        throw new Error('Root is empty, cannot fetch path');\n    }\n    var node = getNodeAtPath(tree, path);\n    if (node == null) {\n        throw new Error(\"Path [\" + path.join(', ') + \"] did not resolve to a node\");\n    }\n    return node;\n}\nexports.getAndAssertNodeAtPathExists = getAndAssertNodeAtPathExists;\n"},"sourceMaps":{"js":{"version":3,"file":"mosaicUtilities.js","sourceRoot":"","sources":["../../src/util/mosaicUtilities.ts"],"names":[],"mappings":"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","sourcesContent":["import clone from 'lodash/clone';\nimport get from 'lodash/get';\nimport { MosaicBranch, MosaicDirection, MosaicKey, MosaicNode, MosaicParent, MosaicPath } from '../types';\n\nfunction alternateDirection<T extends MosaicKey>(\n  node: MosaicNode<T>,\n  direction: MosaicDirection = 'row',\n): MosaicNode<T> {\n  if (isParent(node)) {\n    const nextDirection = getOtherDirection(direction);\n    return {\n      direction,\n      first: alternateDirection(node.first, nextDirection),\n      second: alternateDirection(node.second, nextDirection),\n    };\n  } else {\n    return node;\n  }\n}\n\nexport enum Corner {\n  TOP_LEFT = 1,\n  TOP_RIGHT,\n  BOTTOM_LEFT,\n  BOTTOM_RIGHT,\n}\n\n/**\n * Returns `true` if `node` is a MosaicParent\n * @param node\n * @returns {boolean}\n */\nexport function isParent<T extends MosaicKey>(node: MosaicNode<T>): node is MosaicParent<T> {\n  return (node as MosaicParent<T>).direction != null;\n}\n\n/**\n * Creates a balanced binary tree from `leaves` with the goal of making them as equal area as possible\n * @param leaves\n * @param startDirection\n * @returns {MosaicNode<T>}\n */\nexport function createBalancedTreeFromLeaves<T extends MosaicKey>(\n  leaves: MosaicNode<T>[],\n  startDirection: MosaicDirection = 'row',\n): MosaicNode<T> | null {\n  if (leaves.length === 0) {\n    return null;\n  }\n\n  let current: MosaicNode<T>[] = clone(leaves);\n  let next: MosaicNode<T>[] = [];\n\n  while (current.length > 1) {\n    while (current.length > 0) {\n      if (current.length > 1) {\n        next.push({\n          direction: 'row',\n          first: current.shift()!,\n          second: current.shift()!,\n        });\n      } else {\n        next.unshift(current.shift()!);\n      }\n    }\n    current = next;\n    next = [];\n  }\n  return alternateDirection(current[0], startDirection);\n}\n\n/**\n * Gets the sibling of `branch`\n * @param branch\n * @returns {any}\n */\nexport function getOtherBranch(branch: MosaicBranch): MosaicBranch {\n  if (branch === 'first') {\n    return 'second';\n  } else if (branch === 'second') {\n    return 'first';\n  } else {\n    throw new Error(`Branch '${branch}' not a valid branch`);\n  }\n}\n\n/**\n * Gets the opposite of `direction`\n * @param direction\n * @returns {any}\n */\nexport function getOtherDirection(direction: MosaicDirection): MosaicDirection {\n  if (direction === 'row') {\n    return 'column';\n  } else {\n    return 'row';\n  }\n}\n\n/**\n * Traverses `tree` to find the path to the specified `corner`\n * @param tree\n * @param corner\n * @returns {MosaicPath}\n */\nexport function getPathToCorner(tree: MosaicNode<any>, corner: Corner): MosaicPath {\n  let currentNode: MosaicNode<any> = tree;\n  const currentPath: MosaicPath = [];\n  while (isParent(currentNode)) {\n    if (currentNode.direction === 'row' && (corner === Corner.TOP_LEFT || corner === Corner.BOTTOM_LEFT)) {\n      currentPath.push('first');\n      currentNode = currentNode.first;\n    } else if (currentNode.direction === 'column' && (corner === Corner.TOP_LEFT || corner === Corner.TOP_RIGHT)) {\n      currentPath.push('first');\n      currentNode = currentNode.first;\n    } else {\n      currentPath.push('second');\n      currentNode = currentNode.second;\n    }\n  }\n\n  return currentPath;\n}\n\n/**\n * Gets all leaves of `tree`\n * @param tree\n * @returns {T[]}\n */\nexport function getLeaves<T extends MosaicKey>(tree: MosaicNode<T> | null): T[] {\n  if (tree == null) {\n    return [];\n  } else if (isParent(tree)) {\n    return getLeaves(tree.first).concat(getLeaves(tree.second));\n  } else {\n    return [tree];\n  }\n}\n\n/**\n * Gets node at `path` from `tree`\n * @param tree\n * @param path\n * @returns {MosaicNode<T>|null}\n */\nexport function getNodeAtPath<T extends MosaicKey>(tree: MosaicNode<T> | null, path: MosaicPath): MosaicNode<T> | null {\n  if (path.length > 0) {\n    return get(tree, path, null);\n  } else {\n    return tree;\n  }\n}\n\n/**\n * Gets node at `path` from `tree` and verifies that neither `tree` nor the result are null\n * @param tree\n * @param path\n * @returns {MosaicNode<T>}\n */\nexport function getAndAssertNodeAtPathExists<T extends MosaicKey>(\n  tree: MosaicNode<T> | null,\n  path: MosaicPath,\n): MosaicNode<T> {\n  if (tree == null) {\n    throw new Error('Root is empty, cannot fetch path');\n  }\n  const node = getNodeAtPath(tree, path);\n  if (node == null) {\n    throw new Error(`Path [${path.join(', ')}] did not resolve to a node`);\n  }\n  return node;\n}\n"]}},"error":null,"hash":"4ebbabbb57c100c557989b9510164216","cacheData":{"env":{}}}